using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.Extensions.DependencyInjection.SourceGenerators.Infrastructure;
using Microsoft.Extensions.DependencyInjection.SourceGenerators.Models;

namespace Microsoft.Extensions.DependencyInjection.SourceGenerators;

public static class DependencyInjectionGenerator
{
    public static void Generate(SourceProductionContext context, string assemblyName, ImmutableArray<Service> services)
    {
        context.CancellationToken.ThrowIfCancellationRequested();

        var writer = new SourceWriter()
            .AppendLine("// <auto-generated />")
            .AppendLine();
        
        writer
            .AppendLine()
            .AppendLine("namespace {0};", DependencyInjectionSourceGenerator.Namespace)
            .AppendLine()
            .AppendLine("public static class ServiceCollectionExtensions")
            .AppendLine('{')
            .Indent()
            .AppendLine("public static IServiceCollection AddServicesFrom{0}Assembly(this IServiceCollection services)", assemblyName)
            .AppendLine('{')
            .Indent();
        
        if (services.Length is 0)
            writer.AppendLine("return services;");
        else
            writer
                .AppendLine("return services")
                .Indent();

        var servicesCount = 0;
        
        foreach (var service in services)
        {
            var separator = services.Last().Equals(service) ? ";" : string.Empty;

            var useKeyed = service.Key is not null
                ? "Keyed"
                : string.Empty;

            var key = service.Key is not null
                ? $"\"{service.Key}\""
                : string.Empty;

            switch (service.Lifetime)
            {
                case ServiceLifetime.Singleton:
                    if (service.HasContract)
                        writer.AppendLine(".Add{3}Singleton<{0}, {1}>({4}){2}", service.ContractName, service.Name, separator, useKeyed, key);
                    else
                        writer.AppendLine(".Add{2}Singleton<{0}>({3}){1}", service.Name, separator, useKeyed, key);
                    break;

                case ServiceLifetime.Scoped:
                    if (service.HasContract)
                        writer.AppendLine(".Add{3}Scoped<{0}, {1}>({4}){2}", service.ContractName, service.Name, separator, useKeyed, key);
                    else
                        writer.AppendLine(".Add{2}Scoped<{0}>({3}){1}", service.Name, separator, useKeyed, key);
                    break;

                case ServiceLifetime.Transient:
                    if (service.HasContract)
                        writer.AppendLine(".Add{3}Transient<{0}, {1}>({4}){2}", service.ContractName, service.Name, separator, useKeyed, key);
                    else
                        writer.AppendLine(".Add{2}Transient<{0}>({3}){1}", service.Name, separator, useKeyed, key);
                    break;

                default:
                    continue;
            }
            
            servicesCount++;
        }

        if (servicesCount > 0)
            writer.UnIndent();

        writer
            .UnIndent()
            .AppendLine('}')
            .UnIndent()
            .AppendLine('}');

        context.AddSource("ServiceCollectionExtensions.g.cs", SourceText.From(writer.ToString(), Encoding.UTF8));
    }
}